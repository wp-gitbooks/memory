https://houbb.github.io/2018/10/08/jvm-10-bytecode-execute-enigne



https://blog.csdn.net/dd864140130/article/details/49515403

https://www.jianshu.com/p/58f876f2e8b8

https://juejin.cn/post/6844903871010045960#heading-0



# 概述

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323151055)

有的执行引擎的基本一致：

1. 输入：字节码文件
2. 处理：字节码解析
3. 输出：执行结果



# 运行时栈帧

执行引擎运行的字节码指令都只针对当前帧栈进行操作，在概念模型上，典型的帧栈结构如下（栈是线程私有的，也就是每个线程都会有自己的栈）。

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323151612)

##  局部变量表

局部变量表内部以**变量槽（Variable Slot）**为最小单位。对于byte、char、float、int、short、boolean、reference、returnAddress等长度不超过32位的数据类型，每个局部变量占用一个Slot，double和long这两种64位的数据类型则需要两个Slot。



在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递的，如果执行的是实例方法（非static方法），则局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中通过this来访问这个隐含的参数。



### double float 的非原子性

对于64位的数据类型，比如long和double，JVM会以高位对齐的方式为其分配2个连续的Slot空间。

这里把long和double分割存储的做法与多线程环境下long和double的原子性的做法是一致的。

我们知道，在多线程环境下，**long或者double的读具有原子性，而写不能保证具有原子性**



### 局部变量 slot 重用

局部变量表中的Slot是可重用的，如果当前字节码PC计数器的值已经超出了某变量的作用域，则这个变量对应的Slot可以交给其它变量重用。

重用可以节省栈空间，但也会带来副作用：（为虚拟机设置运行参数加上 `-verbose:gc` 即可输出gc日志信息）

- 测试1

 [java]

```
public static void main(String[] args){
        byte[] placeholder = new byte[64*1000*1000];
        System.gc();
}
```

查看日志，并未回收

 [plaintext]

```
[GC (System.gc())  69437K->63438K(251392K), 0.0012879 secs]
[Full GC (System.gc())  63438K->63277K(251392K), 0.0058505 secs]
```

- 测试 2

 [java]

```
public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1000 * 1000];
        }
        System.gc();
}
```

查看日志，并未回收

 [plaintext]

```
[GC (System.gc())  69437K->63420K(251392K), 0.0011785 secs]
[Full GC (System.gc())  63420K->63277K(251392K), 0.0058676 secs]
```

- 测试 3

 [java]

```
public static void main(String[] args) {
        {
            byte[] placeholder = new byte[64 * 1000 * 1000];
        }
        int a = 0;
        System.gc();
}
```

查看日志，回收了

 [plaintext]

```
[GC (System.gc())  69437K->63454K(251392K), 0.0011921 secs]
[Full GC (System.gc())  63454K->777K(251392K), 0.0056915 secs]
```

测试1中在System.gc()时，变量placeholder还处在作用于之内，不会回收；

测试2在System.gc()时，变量placeholder虽然已经不在作用域，但是placeholder原本所占用的Slot还没有被复用，所以作为GC Root一部分的局部变量表仍然保持着对它的关联，所以也没有回收。这种关联没有被及时打破的影响在绝大部分

### 是否需要手动赋值为 null

下都很轻微，但假如有一个方法，后面的代码有一些耗时很长的操作，而前面又定义了占用大量内存、实际已经不会再使用的变量，则手动将其设为null是有意义的。 还有一点就是，局部变量不像类变量（仅指被static修饰的变量，不包括实例变量）一样存在准备阶段，它不存在系统默认值。

但笔者的观点是**没有必要**把置 null 当做一个普遍的编码规则来推广。

原因有两点：

1. 从编码角度讲，以恰当的变量作用域来控制变量回收时间才是最优雅的解决方法；
2. 从执行角度讲，使用赋null值的操作来优化内存回收是建立在对字节码执行引擎概念模型的理解之上的；

而赋null值的操作在经过 JIT 编译优化后就会被消除掉，这时候将变量设置为null就是没有意义的；

### 局部变量的初始化

局部变量不像前面介绍的类变量那样存在“准备阶段”。

我们知道，类变量在加载过程中要经过两次赋初始值的过程：一次在准备阶段，赋予系统初始值，另外一次在初始化阶段，赋予程序员定义的初始值。

但局部变量不一样，如果一个局部变量定义了但是没有赋初始值是不能使用的。

所有不要认为Java中任何情况下都存在着诸如整型变量默认为0，布尔型变量默认为false之类的默认值。

这一点要好好注意一下。

所以必须为局部变量定义初始值。

 [java]

```
public static void main(String[] args) {
    int a;
    System.out.println(a);
}
```

上面的代码无法运行，编译阶段就会报错。



## 操作数栈

操作数栈，也叫操作栈，是先入后出的栈。其中的元素是**任意的Java数据类型，包括long和double**。

32位数据类型所占容量为1，64位为2。

在方法执行的任何时刻，操作数栈的最大深度都不会超过Code属性中`max_stacks`数据项所设定的最大值。

当一个方法开始执行的时候，操作栈是空的，在方法的执行过程中，会有各种字节码指令出栈/入栈。

例如，在做算术运算的时候，是通过操作栈来进行的，调用其他方法的时候是通过操作栈来进行参数传递的。

例如，整数加法的字节码指令iadd在运行的时候，操作栈中最接近栈顶的两个元素已经存入了两个int型数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。

在概念模型中，两个帧栈作为虚拟机栈的元素是完全独立的，但是在大多数虚拟机实现中都会做优化，将两个帧栈出现一部分重叠：让下面帧栈的部分操作栈与上面帧栈的部分局部变量表重叠，以便在方法调用时共用一部分数据，避免不必要的参数复制传递



## 动态连接

每个帧栈都包含一个指向运行时**常量池中该帧栈所属方法的引用**。

持有这个引用是为了支持方法调用过程中的动态连接。

字节码中的方法调用指令（这里，“方法调用”是指令的修饰词，不要理解错了）以常量池中指向方法的符号引用作为参数。

这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。

另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接



## 方法返回地址

当一个方法开始执行后，有两种方式退出这个方法：

* 正常完成出口

执行引擎遇到方法返回的字节码指令，此时将返回值传递给上层的方法调用者（是否有返回值以及返回值的类型由方法返回指令来决定）

* 异常完成出口

方法执行过程中出现异常，并且该异常没有在方法体中处理（可能是Java虚拟机内部产生的异常，也可能代码中使用athrow字节码指令产生的异常）。

方法退出实际就是当前帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者帧栈的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令。



# 方法调用

## 概述

方法调用并不等同于方法执行，方法调用阶段的唯一目的就是确定被调用的方法的版本（即调用哪个方法）。

一切方法调用在Class文件里存储的都是符号引用，而不是方法的直接引用（方法在实际运行时内存布局中的入口地址）。

在虚拟机中，有5条方法调用字节码指令：

- invokestatic：调用静态方法；
- invokespecial：调用实例构造器 `<init>` 方法、私有方法和父类方法；
- invokevirtual：调用所有的虚方法；
- invokeinterface：调用接口方法，在运行时再确定一个实现此接口的对象；
- invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

方法的调用可以分为解析调用和分派调用

### 非虚方法与虚方法

- 非虚方法

只要能被invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法，私有方法，实例构造器，父类方法4类，他们在类加载的时候就会把符号引用解析为对该方法的直接引用。这些方法称为非虚方法；

- 虚方法：

其他的方法称为虚方法（除去final方法）



## 解析

在类加载中的解析阶段，会将方法调用中的目标方法的一部分符号引用转化为直接引用，这部分可以转化的前提是：方法在程序运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的。这类方法的调用称为解析（或解析调用）。

在Java中，符合上述特点（编译器可知，运行期不可变）的方法：静态方法和私有方法。

与对应方法调用指令，只要能被invokestatic和invokespecial指令调用的方法，都是可以在解析阶段确定唯一调用版本的。这类方法称为非虚方法，其他方法都称为虚方法。

在Java中，非虚方法除了invokestatic和invokespecial指令能调用的方法外，还包括final方法。

解析调用一定是静态的过程，在编译期间就可以完全确定，在类加载的解析阶段就可以把方法的符号引用转变为直接引用，不会延迟到运行期间再去完成。

## 分派

https://houbb.github.io/2018/10/08/jvm-10-bytecode-execute-enigne



### 静态分派



### 动态分派



## 单分派和多分派



## 虚拟机动态分派的实现





# 基于栈的字节码解释执行引擎

##  解释执行 & 编译执行 & 编译器



## 基于栈的指令集和基于寄存器的指令集



## 基于栈的解释器执行过程

