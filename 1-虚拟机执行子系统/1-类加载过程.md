# 概述

1、什么是类加载？什么时候进行类加载？

2、什么是类初始化？什么时候进行类初始化？

3、什么时候会为变量分配内存？

4、什么时候会为变量赋默认初值？什么时候会为变量赋程序设定的初值？

5、类加载器是什么？

6、如何编写一个自定义的类加载器？

什么是类加载？类的加载过程（生命周期）？类什么时候初始化？类初始化顺序？类加载器、反射、字节码等一系列问题。





# 类加载的过程

## 类的生命周期

```
加载 --> 验证 --> 准备 --> 解析 --> 初始化 --> 使用 --> 卸载
       |<------- 连接 ------->|
|<------------- 类加载 ---------------->|
```

![类的生命周期](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144307)



## 加载

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144211)

### 加载的 3 个阶段

- 通过类的全限定名获取二进制字节流（将 .class 文件读进内存）；
- 将字节流的静态存储结构转化为运行时的数据结构；
- 在内存中生成该类的 Class 对象；
  - HotSpot 虚拟机把这个对象放在方法区，非 Java 堆

###  类-分类

- 非数组类
  - 系统提供的引导**类加载器**
  - 用户自定义的**类加载器**
- 数组类
  - 不通过类加载器，由 **Java 虚拟机**直接创建
  - 创建动作由 newarray 指令触发，new 实际上触发了 `[L全类名` 对象的初始化
  - 规则
    - 数组元素是引用类型
      - 加载：递归加载其组件
      - 可见性：与引用类型一致
    - 数组元素是非引用类型
      - 加载：与引导类加载器关联
      - 可见性：public

## 验证

![](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144155)

- **目的：** 确保 .class 文件中的字节流信息符合虚拟机的要求。
- 4 个验证过程：
  - 文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” `0xCAFEBABE`
  - 元数据验证：保证字节码描述信息符号 Java 规范（语义分析）
  - 字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）
  - 符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验
- 这个操作虽然重要，但不是必要的，可以通过 `-Xverify:none` 关掉



## 准备(重点)

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144141)

- **描述：** 为 **static 变量**在**方法区**分配内存。(主要是为**类变量**（注意，不是实例变量）分配内存，并且赋予初值。)

- static 变量准备后的初始值：

  - ```
    public static int value = 123;
    ```

    - 准备后为 0，value 的赋值指令 putstatic 会被放在 `<clinit>()` 方法中，`<clinit>()`方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。

  - ```
    public static final int value = 123;
    ```

    - 准备后为 123，因为被 `static final` 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。

- 比如**8种基本类型**的初值，默认为0；**引用类型的初值**则为null；常量的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323142553.jpeg)





## 解析(重点)

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323143731)

- 描述：

  将常量池中的 “符号引用” 替换为 “直接引用”。

  - 在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。
  - 什么是 “符号引用” 和 “直接引用” ？
    - 符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。
    - 直接引用：直接指向被**引用目标在内存中的位置的指针**等，也就是说，引用的目标一定存在于内存中。



### 符号引用

符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。符号引用于JVM内存布局无关。

> 符号引用的作用是在编译的过程中，JVM并不知道引用的具体地址，所以用符号引用进行代替，而在解析阶段将会将这个符号引用转换为真正的内存地址。

### 直接引用

可以是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。有了直接引用，那么引用的目标必定已经在虚拟机内存中

直接引用可以理解为：指向**类对象、变量、方法**的指针、指向**实例**的指针和一个**间接定位**到对象的对象句柄。

举例：

```
public class Test{
   public static void main(String[] args) {
     String s="adc";
     System.out.println("s="+s);
   }
}
```

上面这段代码的变量`s`在编译时会被解析成为符号引用，符号引用的标志是`astore_<n>`，对应下图的`astore_1`

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144913)

我们在方法里定义了一个局部变量`s`，把它指向`adc`存放的地址，但是在编译时`s`并不知道`adc`的地址，JVM将变量`s`与`astore_1`对应起来，`astore_1`的含义是将操作数栈顶的`adc`保存回索引为`1`的局部变量表中，此时访问变量`s`就会读取局部变量表索引值为`1`中的数据。所以局部变量`s`就是一个符号引用。

下面这段代码的字符串被解析为直接引用

```
public class Test{
    public static void main(String[] args) {
        System.out.println("s="+"adc");
    }
}
```

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323144940)

我们可以看到字节码指令`ldc`直接将`s=abc`这一字符串从常量池中推送到栈，然后下一条字节码指令`invokevirtual`代表调用实例方法，并没有将字符串存入局部变量表中，所以这里的`s=abc`就是一个直接引用。

总结一下：符号引用是指在编译时无法确定对象的内存地址，所以必须使用一个符号引用去对应局部变量表中的一个特定位置，然后在解析阶段将该变量的值或引用地址保存回局部变量表中，此后访问该变量值都会从局部变量表对应的位置查找该值；而直接引用是在编译时就可以确定。







解析阶段是虚拟机**将常量池内的符号引用替换为直接引用**的过程。**符号引用**就是一组符号来描述目标，可以是任何字面量；**直接引用**就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行。下面将讲解前面4种引用的解析过程。

- **类或接口的解析**

假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，虚拟机需要以下3个步骤：

（1）如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。

（2）如果C是一个数组类型，并且数组的元素类型为对象，那将会按照第1点的规则加载数组元素类型。

（3）如果上面的步骤没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成之前还要进行符号引用验证，确认D是否具备对C的访问权限。

- **字段解析**

要解析一个未被解析过的字段符号引用，首先将会对字段所属的类或接口的符号引用进行解析。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败。如果解析成功完成，那将这个字段所属的类或接口用C表示，虚拟机规范要求按照如下步骤对C进行后续字段的搜索：

（1）如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

（2）否则，如果在C中实现了接口，就会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

（3）否则，如果C不是java.lang.Object的话，就会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。

（4）否则，查找失败，抛出**java.lang.NoSuchFieldError**异常。

最后，如果查找过程成功返回了直接引用，就会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出**java.lang.IllegalAccessError**异常。

- **类方法解析**

类方法解析也需要先解析出类方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个类，接下来虚拟机将会按照如下步骤进行后续的类方法搜索：

（1）类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现C是个接口，直接抛出异常。

（2）否则，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

（3）否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

（4）否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，查找结束，抛出异常。

（5）否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`异常。

最后，如果查找过程成功返回了直接引用，就会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出`java.lang.IllegalAccessError`异常。

- **接口方法解析**

接口方法解析也需要先解析出接口方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤进行后续的接口方法搜索：

（1）如果在接口方法表中发现C是个类而不是接口，直接抛出异常。

（2）否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

（3）否则，在接口C的父接口中递归查找，直到java.lang.Object类为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。

（4）否则，宣告方法查找失败，抛出`java.lang.NoSuchMethodError`异常。

由于接口中的所有方法默认都是`public`的，所以不存在访问权限的问题。



## 初始化(重点)

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323143822)

- **描述：** 执行类构造器 `<clinit>()` 方法的过程。 (这个阶段主要是对**类变量初始化**，是执行类构造器的过程。换句话说只对static修饰的变量或语句进行初始化)

  如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。

  如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行

- `<clinit>()` 方法

  - 包含的内容：

    - 所有 static 的赋值操作；
    - static 块中的语句；

  - ```
    <clinit>()
    ```

    方法中的语句顺序：

    - 基本按照语句在源文件中出现的顺序排列；
    - 静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。

  - 与

     

    ```
    <init>()
    ```

     

    的不同：

    - 不需要显示调用父类的 `<clinit>()` 方法；

    - 虚拟机保证在子类的

       

      ```
      <clinit>()
      ```

       

      方法执行前，父类的

       

      ```
      <clinit>()
      ```

       

      方法一定执行完毕。

      - 也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。

  - 接口与类的不同：

    - 执行子接口的 `<clinit>()` 方法前不需要先执行父接口的 `<clinit>()` 方法（除非用到了父接口中定义的 public static final 变量）；

  - 执行过程中加锁：

    - 同一时刻只能有一个线程在执行 `<clinit>()` 方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。

  - 非必要性：

    - 一个类如果没有任何 static 的内容就不需要执行 `<clinit>()` 方法。

*注：初始化时，才真正开始执行类中定义的 Java 代码。*



### 类加载的时机(类合适被初始化)



### 类初始化顺序



# 类加载的时机(类何时初始化)

JVM 会在程序第一次主动引用类的时候，加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。那么什么是主动引用，什么是被动引用呢？

只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源



## 引用(主动引用&被动引用)

 ### 主动引用

- 遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：
  - 使用 new 实例化对象；
  - 读取或设置一个类的 static 字段（被 final 修饰的除外）；
  - 调用类的静态方法。
- 对类进行反射调用；
- 初始化一个类时，其父类还没初始化（需先初始化父类）；
  - 这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。
- 虚拟机启动，先初始化包含 main() 函数的主类；
- JDK 1.7 动态语言支持：一个 java.lang.invoke.MethodHandle 的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic



### **被动引用**

 

- 被动引用
  - 通过子类引用父类静态字段，不会导致子类初始化；
  - `Array[] arr = new Array[10];` 不会触发 Array 类初始化；
  - `static final VAR` 在编译阶段会存入调用类的常量池，通过 `ClassName.VAR` 引用不会触发 ClassName 初始化。

 

## 类的显式加载和隐式加载

### 显示加载

- 调用 `ClassLoader#loadClass(className)` 或 `Class.forName(className)`。
- 两种显示加载 .class 文件的区别：
  - `Class.forName(className)` 加载 class 的同时会初始化静态域，`ClassLoader#loadClass(className)` 不会初始化静态域；
  - Class.forName 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。



### 隐式加载

- new 类对象；
- 使用类的静态域；
- 创建子类对象；
- 使用子类的静态域；
- 其他的隐式加载，在 JVM 启动时：
  - BootStrapLoader 会加载一些 JVM 自身运行所需的 Class；
  - ExtClassLoader 会加载指定目录下一些特殊的 Class；
  - AppClassLoader 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件



# 类初始化顺序

程序的执行顺序为：
如果类还没有被加载：
1、先执行父类的静态代码块和静态变量初始化，并且静态代码块和静态变量的执行顺序只跟代码中出现的顺序有关。
2、执行子类的静态代码块和静态变量初始化。
3、执行父类的实例变量初始化
4、执行父类的构造函数
5、执行子类的实例变量初始化
6、执行子类的构造函数

```
public class test {                         //1.第一步，准备加载类

    public static void main(String[] args) {
        new test();                         //4.第四步，new一个类，但在new之前要处理匿名代码块        
    }

    static int num = 4;                    //2.第二步，静态变量和静态代码块的加载顺序由编写先后决定 

    {
        num += 3;
        System.out.println("b");           //5.第五步，按照顺序加载匿名代码块，代码块中有打印
    }

    int a = 5;                             //6.第六步，按照顺序加载变量

    { // 成员变量第三个
        System.out.println("c");           //7.第七步，按照顺序打印c
    }

    test() { // 类的构造函数，第四个加载
        System.out.println("d");           //8.第八步，最后加载构造函数，完成对象的建立
    }

    static {                              // 3.第三步，静态块，然后执行静态代码块，因为有输出，故打印a
        System.out.println("a");
    }

    static void run()                    // 静态方法，调用的时候才加载// 注意看，e没有加载
    {
        System.out.println("e");
    }
}
```

一般顺序：静态块（静态变量）——>成员变量——>构造方法——>静态方法
1、静态代码块（只加载一次） 2、构造方法（创建一个实例就加载一次）3、静态方法需要调用才会执行，所以最后结果没有e

![这里写图片描述](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323142258.jpeg)

```
public class Print {

     public Print(String s){
         System.out.print(s + " ");
     }
 }
 
 
 public class Parent{

     public static Print obj1 = new Print("1");

     public Print obj2 = new Print("2");

     public static Print obj3 = new Print("3");

     static{
         new Print("4");
     }

     public static Print obj4 = new Print("5");

     public Print obj5 = new Print("6");

     public Parent(){
         new Print("7");
     }

 }


public class Child extends Parent{

     static{
         new Print("a");
     }

     public static Print obj1 = new Print("b");

     public Print obj2 = new Print("c");

     public Child (){
         new Print("d");
     }

     public static Print obj3 = new Print("e");

     public Print obj4 = new Print("f");

     public static void main(String [] args){
         Parent obj1 = new Child ();
         Parent obj2 = new Child ();
     }
 }
```

执行main方法，程序输出顺序为： 1 3 4 5 a b e 2 6 7 c f d 2 6 7 c f d 





