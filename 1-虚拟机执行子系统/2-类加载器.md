# 类加载器概述

# 如何判断两个类 “相等”

 

- “相等” 的要求
  - 同一个 .class 文件
  - 被同一个虚拟机加载
  - 被同一个类加载器加载
- 判断 “相等” 的方法
  - `instanceof` 关键字
  - Class 对象中的方法：
    - `equals()`
    - `isInstance()`
    - `isAssignableFrom()`



# 类加载器的分类

 类加载器的分类

- 启动类加载器（Bootstrap）
  - <JAVA_HOME>/lib
  - -Xbootclasspath 参数指定的路径
- 扩展类加载器（Extension）
  - <JAVA_HOME>/lib/ext
  - java.ext.dirs 系统变量指定的路径
- 应用程序类加载器（Application）
  - -classpath 参数



# 双亲委派模型

![img](https://cdn.jsdelivr.net/gh/wp3355168/Typora-Picgo-Gitee/img/20210323143044.png)

- 工作过程
  - 当前类加载器收到类加载的请求后，先不自己尝试加载类，而是先将请求委派给父类加载器
    - 因此，所有的类加载请求，都会先被传送到启动类加载器
  - 只有当父类加载器加载失败时，当前类加载器才会尝试自己去自己负责的区域加载
- 实现
  - 检查该类是否已经被加载
  - 将类加载请求委派给父类
    - 如果父类加载器为 null，默认使用启动类加载器
    - `parent.loadClass(name, false)`
  - 当父类加载器加载失败时
    - catch ClassNotFoundException 但不做任何处理
    - 调用自己的 findClass() 去加载
      - 我们在实现自己的类加载器时只需要 `extends ClassLoader`，然后重写 `findClass()` 方法而不是 `loadClass()` 方法，这样就不用重写 `loadClass()` 中的双亲委派机制了
- 优点
  - 自己写的类库同名类不会覆盖类库的类



# 自定义类加载器

https://my.oschina.net/u/4313515/blog/4187249

http://fanyilun.me/2018/12/29/%E7%90%86%E8%A7%A3Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/#OSGi

https://juejin.cn/post/6844904041131016200#heading-16